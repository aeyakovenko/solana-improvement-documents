---
simd: '0010'
title: Diet Clients
authors:
  - Anatoly Yakovenko (Solana Labs)
category: Sealevel Virtual Machine
type: Standards Track
status: Draft
created: 2022-12-09
---

## Summary

Users that don't run a full node need secure access to the solana
blockchain. The goal of this proposal is to define a protocol for
sampling the validators such that if at least a small minority of
validators are not faulty the user can be notified of an invalid
state transition or a double confirmation attack on the network.

## Specification

### Overview

1. User observes a confirmation for a TX at slot N. Confirmation
contains 2/3+ votes for slot N, and a path from the transaction to
the bankhash signed by all the votes.

2. Concurrently, user requests at random votes from N different
nodes. Votes maybe for later slots, and would contain a path to the
requested slot's bankhash.

3. If all the responses are the same, the user is done. 

4. If X% or more of staked nodes responds that they do not have block,
the user starts sampling nodes at random for missing shreds and
submitting the shreds to the validators with the missing block.

    a. This process may need to run recursively until the fork block
    is repaired.

    b. If shreds cannot be recovered, a fault has occurred. User
    shouldn't trust the confirmation.

5. If X% or more of the staked nodes respond with different
bankhash, a fault has occurred on the network. User shouldn't
trust the confirmation.

### Confirmation Proof

#### BankHash

BankHash = Merkle(ShredHash, BlockHash, StateHash, Prev BankHash)

#### ShredHash: Data availability merkle tree

This tree is necessary for step 4 in the protocol. If enough nodes
respond that they do not have the data, the client should try to
repair the data for them. This prevents the faulty majority from
withholding the data from the rest of the network, so the rest can
identify an invalid state transition or a double confirmation.

Turbine, solana's block propagation protocol, transmits blocks in
small chunks called shreds. Shreds are transmitted in batches.
Each batch includes N data shreds and M erasure codes.

Upon executing the block, the validator should compute the merkle
root of all the shreds, including the erasure shreds. The merkle
root should be added to the BankHash, which is signed by validators
when voting.

When sampling for shreds, the user knows that the shreds are for
the proposed confirmed block because each shred has a merkle path
to the bankhash that was signed by all the validators.

#### StateHash: Transaction state transition merkle tree

Merkle root of all the outputs from all the transactions and the
status codes.

### Future work: Separating execution and fork choice

Eventually the solana protocol will separate fork choice from
computing all the state transitions for all the programs. Diet
clients would need to be modified to provide confirmation of execution
for users.

BankHash = (ShredHash, BlockHash, VoteStateHash, Prev BankHash)

VoteStateHash = Current TX State Results for votes only

ProgramStateHash = (Current TX State Results, Previous ProgramStateHash)

While validators vote only on the BankHash, users still need to
know the ProgramStateHash for the slot. 

Validators are not expected to compute the ProgramStateHash at the
same time as the BankHash, and the ProgramStateHash may lag.  But
at least once an epoch, all the validators must compute the EpochHash
for the previous epoch, which includes all the ProgramStateHashe from the
previous epoch.

Epoch Hash = Merkle root of all the accounts including the account
that stores ProgramStateHashes for the epoch

#### Overview

The original protocol is modified as follows:

2. Concurrently, user requests at random for votes from N different
nodes. Votes maybe for later slots, and would contain a path to the
requested slot's bankhash.
2.a User also requests signed ProgramStateHash attestations from
the staked validators.

If the validator signed an invalid ProgramStateHash, this signed
attestation can be used to slash them after the EpochHash has been
computed by the network.
