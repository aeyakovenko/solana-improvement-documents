---
simd: '0004'
title: Diet Clients
authors:
  - Anatoly Yakovenko (Solana Labs)
category: Sealevel Virtual Machine
type: Standards Track
status: Draft
created: 2022-12-09
---

## Summary

Users that don't run a full node need secure access to the solana
blockchain. The goal of this proposal is to define a protocol for
sampling the validators such that if only a small minority of
validators are not faulty the user can be notified of an invalid
state transition or a double confirmation attack on the network.

## Specification

### Overview

1. User observes a confirmation for a TX at slot N. Confirmation
contains 2/3+ votes for slot N, and a path from the transaction to
the signed bankhash.

2. Concurrently, user requests at random for votes from N different
nodes. Votes maybe for later slots, and would contain a path to the
requested slot's bankhash.

3. If all the responses are the same, the user is done. 

4. If X% or more of staked nodes responds that they do not have block,
the user starts sampling nodes at random for missing shreds and
submitting the shreds to the validators with the missing block.

    a. This process may need to run recursively until the fork block
    is repaired.

    b. If shreds cannot be recovered, a fault has occurred. User
    shouldn't trust the confirmation.

5. If X% or more of the staked nodes respond with different
bankhash, a fault has occurred on the network. User shouldn't
trust the confirmation.

### Confirmation Proof

#### BankHash

BankHash = Merkle(ShredHash, BlockHash, StateHash, Prev BankHash)

#### ShredHash: Data availability merkle tree

This tree is necessary for step 4 in the protocol. If enough nodes
respond that they do not have the data, the client should try to
repair the data for them. This prevents the faulty majority from
withholding the data from the rest of the network, so the rest can
identify an invalid state transition or a double confirmation.

Turbine, solana's block propagation protocol, transmits blocks in
small chunks called shreds.  Shreds are transmitted in batches.
Each batch includes N data shreds and M erasure codes.

Upon executing the block, the validator should compute the merkle
root of all the shreds, including the erasure codes.  The merkle
root should be added to the BankHash, which is signed by validators
when voting.

#### StateHash: Transaction state transition merkle tree

Merkle root of all the outputs from all the transactions and the
status codes.

### Future work: Separating execution and fork choice

The computation for Bankhash is decoupled from StateHash

BankHash = (ShredHash, BlockHash, Prev BankHash)

StateHash = (Current TX StateResults, Previous StateHash)

While validators vote only on the BankHash, users still need to
know the StateHash for the slot. 

Validators are not expected to compute StateHash at the same time
as the BankHash, and the StateHash may lag.  But at least once an
epoch, all the validators must compute the EpochHash for the previous
epoch, which includes all the StateHashes from the previous epoch.

Epoch Hash = (Merkle root of all the accounts,All the epoch StateHashes)

#### Overview

2. Concurrently, user requests at random for votes from N different
nodes. Votes maybe for later slots, and would contain a path to the
requested slot's bankhash.
    a. User also requests StateHash attestations from the nodes.


If the validator signed an invalid StateHash, this attestation can
be used to slash them after the EpochHash has been computed by the
network.
